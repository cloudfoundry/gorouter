// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"code.cloudfoundry.org/gorouter/logger"
	"github.com/uber-go/zap"
)

type FakeLogger struct {
	WithStub        func(...zap.Field) logger.Logger
	withMutex       sync.RWMutex
	withArgsForCall []struct {
		arg1 []zap.Field
	}
	withReturns struct {
		result1 logger.Logger
	}
	withReturnsOnCall map[int]struct {
		result1 logger.Logger
	}
	CheckStub        func(zap.Level, string) *zap.CheckedMessage
	checkMutex       sync.RWMutex
	checkArgsForCall []struct {
		arg1 zap.Level
		arg2 string
	}
	checkReturns struct {
		result1 *zap.CheckedMessage
	}
	checkReturnsOnCall map[int]struct {
		result1 *zap.CheckedMessage
	}
	LogStub        func(zap.Level, string, ...zap.Field)
	logMutex       sync.RWMutex
	logArgsForCall []struct {
		arg1 zap.Level
		arg2 string
		arg3 []zap.Field
	}
	DebugStub        func(string, ...zap.Field)
	debugMutex       sync.RWMutex
	debugArgsForCall []struct {
		arg1 string
		arg2 []zap.Field
	}
	InfoStub        func(string, ...zap.Field)
	infoMutex       sync.RWMutex
	infoArgsForCall []struct {
		arg1 string
		arg2 []zap.Field
	}
	WarnStub        func(string, ...zap.Field)
	warnMutex       sync.RWMutex
	warnArgsForCall []struct {
		arg1 string
		arg2 []zap.Field
	}
	ErrorStub        func(string, ...zap.Field)
	errorMutex       sync.RWMutex
	errorArgsForCall []struct {
		arg1 string
		arg2 []zap.Field
	}
	DPanicStub        func(string, ...zap.Field)
	dPanicMutex       sync.RWMutex
	dPanicArgsForCall []struct {
		arg1 string
		arg2 []zap.Field
	}
	PanicStub        func(string, ...zap.Field)
	panicMutex       sync.RWMutex
	panicArgsForCall []struct {
		arg1 string
		arg2 []zap.Field
	}
	FatalStub        func(string, ...zap.Field)
	fatalMutex       sync.RWMutex
	fatalArgsForCall []struct {
		arg1 string
		arg2 []zap.Field
	}
	SessionStub        func(string) logger.Logger
	sessionMutex       sync.RWMutex
	sessionArgsForCall []struct {
		arg1 string
	}
	sessionReturns struct {
		result1 logger.Logger
	}
	sessionReturnsOnCall map[int]struct {
		result1 logger.Logger
	}
	SessionNameStub        func() string
	sessionNameMutex       sync.RWMutex
	sessionNameArgsForCall []struct{}
	sessionNameReturns     struct {
		result1 string
	}
	sessionNameReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeLogger) With(arg1 ...zap.Field) logger.Logger {
	fake.withMutex.Lock()
	ret, specificReturn := fake.withReturnsOnCall[len(fake.withArgsForCall)]
	fake.withArgsForCall = append(fake.withArgsForCall, struct {
		arg1 []zap.Field
	}{arg1})
	fake.recordInvocation("With", []interface{}{arg1})
	fake.withMutex.Unlock()
	if fake.WithStub != nil {
		return fake.WithStub(arg1...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.withReturns.result1
}

func (fake *FakeLogger) WithCallCount() int {
	fake.withMutex.RLock()
	defer fake.withMutex.RUnlock()
	return len(fake.withArgsForCall)
}

func (fake *FakeLogger) WithArgsForCall(i int) []zap.Field {
	fake.withMutex.RLock()
	defer fake.withMutex.RUnlock()
	return fake.withArgsForCall[i].arg1
}

func (fake *FakeLogger) WithReturns(result1 logger.Logger) {
	fake.WithStub = nil
	fake.withReturns = struct {
		result1 logger.Logger
	}{result1}
}

func (fake *FakeLogger) WithReturnsOnCall(i int, result1 logger.Logger) {
	fake.WithStub = nil
	if fake.withReturnsOnCall == nil {
		fake.withReturnsOnCall = make(map[int]struct {
			result1 logger.Logger
		})
	}
	fake.withReturnsOnCall[i] = struct {
		result1 logger.Logger
	}{result1}
}

func (fake *FakeLogger) Check(arg1 zap.Level, arg2 string) *zap.CheckedMessage {
	fake.checkMutex.Lock()
	ret, specificReturn := fake.checkReturnsOnCall[len(fake.checkArgsForCall)]
	fake.checkArgsForCall = append(fake.checkArgsForCall, struct {
		arg1 zap.Level
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Check", []interface{}{arg1, arg2})
	fake.checkMutex.Unlock()
	if fake.CheckStub != nil {
		return fake.CheckStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.checkReturns.result1
}

func (fake *FakeLogger) CheckCallCount() int {
	fake.checkMutex.RLock()
	defer fake.checkMutex.RUnlock()
	return len(fake.checkArgsForCall)
}

func (fake *FakeLogger) CheckArgsForCall(i int) (zap.Level, string) {
	fake.checkMutex.RLock()
	defer fake.checkMutex.RUnlock()
	return fake.checkArgsForCall[i].arg1, fake.checkArgsForCall[i].arg2
}

func (fake *FakeLogger) CheckReturns(result1 *zap.CheckedMessage) {
	fake.CheckStub = nil
	fake.checkReturns = struct {
		result1 *zap.CheckedMessage
	}{result1}
}

func (fake *FakeLogger) CheckReturnsOnCall(i int, result1 *zap.CheckedMessage) {
	fake.CheckStub = nil
	if fake.checkReturnsOnCall == nil {
		fake.checkReturnsOnCall = make(map[int]struct {
			result1 *zap.CheckedMessage
		})
	}
	fake.checkReturnsOnCall[i] = struct {
		result1 *zap.CheckedMessage
	}{result1}
}

func (fake *FakeLogger) Log(arg1 zap.Level, arg2 string, arg3 ...zap.Field) {
	fake.logMutex.Lock()
	fake.logArgsForCall = append(fake.logArgsForCall, struct {
		arg1 zap.Level
		arg2 string
		arg3 []zap.Field
	}{arg1, arg2, arg3})
	fake.recordInvocation("Log", []interface{}{arg1, arg2, arg3})
	fake.logMutex.Unlock()
	if fake.LogStub != nil {
		fake.LogStub(arg1, arg2, arg3...)
	}
}

func (fake *FakeLogger) LogCallCount() int {
	fake.logMutex.RLock()
	defer fake.logMutex.RUnlock()
	return len(fake.logArgsForCall)
}

func (fake *FakeLogger) LogArgsForCall(i int) (zap.Level, string, []zap.Field) {
	fake.logMutex.RLock()
	defer fake.logMutex.RUnlock()
	return fake.logArgsForCall[i].arg1, fake.logArgsForCall[i].arg2, fake.logArgsForCall[i].arg3
}

func (fake *FakeLogger) Debug(arg1 string, arg2 ...zap.Field) {
	fake.debugMutex.Lock()
	fake.debugArgsForCall = append(fake.debugArgsForCall, struct {
		arg1 string
		arg2 []zap.Field
	}{arg1, arg2})
	fake.recordInvocation("Debug", []interface{}{arg1, arg2})
	fake.debugMutex.Unlock()
	if fake.DebugStub != nil {
		fake.DebugStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) DebugCallCount() int {
	fake.debugMutex.RLock()
	defer fake.debugMutex.RUnlock()
	return len(fake.debugArgsForCall)
}

func (fake *FakeLogger) DebugArgsForCall(i int) (string, []zap.Field) {
	fake.debugMutex.RLock()
	defer fake.debugMutex.RUnlock()
	return fake.debugArgsForCall[i].arg1, fake.debugArgsForCall[i].arg2
}

func (fake *FakeLogger) Info(arg1 string, arg2 ...zap.Field) {
	fake.infoMutex.Lock()
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct {
		arg1 string
		arg2 []zap.Field
	}{arg1, arg2})
	fake.recordInvocation("Info", []interface{}{arg1, arg2})
	fake.infoMutex.Unlock()
	if fake.InfoStub != nil {
		fake.InfoStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeLogger) InfoArgsForCall(i int) (string, []zap.Field) {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return fake.infoArgsForCall[i].arg1, fake.infoArgsForCall[i].arg2
}

func (fake *FakeLogger) Warn(arg1 string, arg2 ...zap.Field) {
	fake.warnMutex.Lock()
	fake.warnArgsForCall = append(fake.warnArgsForCall, struct {
		arg1 string
		arg2 []zap.Field
	}{arg1, arg2})
	fake.recordInvocation("Warn", []interface{}{arg1, arg2})
	fake.warnMutex.Unlock()
	if fake.WarnStub != nil {
		fake.WarnStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) WarnCallCount() int {
	fake.warnMutex.RLock()
	defer fake.warnMutex.RUnlock()
	return len(fake.warnArgsForCall)
}

func (fake *FakeLogger) WarnArgsForCall(i int) (string, []zap.Field) {
	fake.warnMutex.RLock()
	defer fake.warnMutex.RUnlock()
	return fake.warnArgsForCall[i].arg1, fake.warnArgsForCall[i].arg2
}

func (fake *FakeLogger) Error(arg1 string, arg2 ...zap.Field) {
	fake.errorMutex.Lock()
	fake.errorArgsForCall = append(fake.errorArgsForCall, struct {
		arg1 string
		arg2 []zap.Field
	}{arg1, arg2})
	fake.recordInvocation("Error", []interface{}{arg1, arg2})
	fake.errorMutex.Unlock()
	if fake.ErrorStub != nil {
		fake.ErrorStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) ErrorCallCount() int {
	fake.errorMutex.RLock()
	defer fake.errorMutex.RUnlock()
	return len(fake.errorArgsForCall)
}

func (fake *FakeLogger) ErrorArgsForCall(i int) (string, []zap.Field) {
	fake.errorMutex.RLock()
	defer fake.errorMutex.RUnlock()
	return fake.errorArgsForCall[i].arg1, fake.errorArgsForCall[i].arg2
}

func (fake *FakeLogger) DPanic(arg1 string, arg2 ...zap.Field) {
	fake.dPanicMutex.Lock()
	fake.dPanicArgsForCall = append(fake.dPanicArgsForCall, struct {
		arg1 string
		arg2 []zap.Field
	}{arg1, arg2})
	fake.recordInvocation("DPanic", []interface{}{arg1, arg2})
	fake.dPanicMutex.Unlock()
	if fake.DPanicStub != nil {
		fake.DPanicStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) DPanicCallCount() int {
	fake.dPanicMutex.RLock()
	defer fake.dPanicMutex.RUnlock()
	return len(fake.dPanicArgsForCall)
}

func (fake *FakeLogger) DPanicArgsForCall(i int) (string, []zap.Field) {
	fake.dPanicMutex.RLock()
	defer fake.dPanicMutex.RUnlock()
	return fake.dPanicArgsForCall[i].arg1, fake.dPanicArgsForCall[i].arg2
}

func (fake *FakeLogger) Panic(arg1 string, arg2 ...zap.Field) {
	fake.panicMutex.Lock()
	fake.panicArgsForCall = append(fake.panicArgsForCall, struct {
		arg1 string
		arg2 []zap.Field
	}{arg1, arg2})
	fake.recordInvocation("Panic", []interface{}{arg1, arg2})
	fake.panicMutex.Unlock()
	if fake.PanicStub != nil {
		fake.PanicStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) PanicCallCount() int {
	fake.panicMutex.RLock()
	defer fake.panicMutex.RUnlock()
	return len(fake.panicArgsForCall)
}

func (fake *FakeLogger) PanicArgsForCall(i int) (string, []zap.Field) {
	fake.panicMutex.RLock()
	defer fake.panicMutex.RUnlock()
	return fake.panicArgsForCall[i].arg1, fake.panicArgsForCall[i].arg2
}

func (fake *FakeLogger) Fatal(arg1 string, arg2 ...zap.Field) {
	fake.fatalMutex.Lock()
	fake.fatalArgsForCall = append(fake.fatalArgsForCall, struct {
		arg1 string
		arg2 []zap.Field
	}{arg1, arg2})
	fake.recordInvocation("Fatal", []interface{}{arg1, arg2})
	fake.fatalMutex.Unlock()
	if fake.FatalStub != nil {
		fake.FatalStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) FatalCallCount() int {
	fake.fatalMutex.RLock()
	defer fake.fatalMutex.RUnlock()
	return len(fake.fatalArgsForCall)
}

func (fake *FakeLogger) FatalArgsForCall(i int) (string, []zap.Field) {
	fake.fatalMutex.RLock()
	defer fake.fatalMutex.RUnlock()
	return fake.fatalArgsForCall[i].arg1, fake.fatalArgsForCall[i].arg2
}

func (fake *FakeLogger) Session(arg1 string) logger.Logger {
	fake.sessionMutex.Lock()
	ret, specificReturn := fake.sessionReturnsOnCall[len(fake.sessionArgsForCall)]
	fake.sessionArgsForCall = append(fake.sessionArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Session", []interface{}{arg1})
	fake.sessionMutex.Unlock()
	if fake.SessionStub != nil {
		return fake.SessionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.sessionReturns.result1
}

func (fake *FakeLogger) SessionCallCount() int {
	fake.sessionMutex.RLock()
	defer fake.sessionMutex.RUnlock()
	return len(fake.sessionArgsForCall)
}

func (fake *FakeLogger) SessionArgsForCall(i int) string {
	fake.sessionMutex.RLock()
	defer fake.sessionMutex.RUnlock()
	return fake.sessionArgsForCall[i].arg1
}

func (fake *FakeLogger) SessionReturns(result1 logger.Logger) {
	fake.SessionStub = nil
	fake.sessionReturns = struct {
		result1 logger.Logger
	}{result1}
}

func (fake *FakeLogger) SessionReturnsOnCall(i int, result1 logger.Logger) {
	fake.SessionStub = nil
	if fake.sessionReturnsOnCall == nil {
		fake.sessionReturnsOnCall = make(map[int]struct {
			result1 logger.Logger
		})
	}
	fake.sessionReturnsOnCall[i] = struct {
		result1 logger.Logger
	}{result1}
}

func (fake *FakeLogger) SessionName() string {
	fake.sessionNameMutex.Lock()
	ret, specificReturn := fake.sessionNameReturnsOnCall[len(fake.sessionNameArgsForCall)]
	fake.sessionNameArgsForCall = append(fake.sessionNameArgsForCall, struct{}{})
	fake.recordInvocation("SessionName", []interface{}{})
	fake.sessionNameMutex.Unlock()
	if fake.SessionNameStub != nil {
		return fake.SessionNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.sessionNameReturns.result1
}

func (fake *FakeLogger) SessionNameCallCount() int {
	fake.sessionNameMutex.RLock()
	defer fake.sessionNameMutex.RUnlock()
	return len(fake.sessionNameArgsForCall)
}

func (fake *FakeLogger) SessionNameReturns(result1 string) {
	fake.SessionNameStub = nil
	fake.sessionNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeLogger) SessionNameReturnsOnCall(i int, result1 string) {
	fake.SessionNameStub = nil
	if fake.sessionNameReturnsOnCall == nil {
		fake.sessionNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.sessionNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeLogger) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.withMutex.RLock()
	defer fake.withMutex.RUnlock()
	fake.checkMutex.RLock()
	defer fake.checkMutex.RUnlock()
	fake.logMutex.RLock()
	defer fake.logMutex.RUnlock()
	fake.debugMutex.RLock()
	defer fake.debugMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.warnMutex.RLock()
	defer fake.warnMutex.RUnlock()
	fake.errorMutex.RLock()
	defer fake.errorMutex.RUnlock()
	fake.dPanicMutex.RLock()
	defer fake.dPanicMutex.RUnlock()
	fake.panicMutex.RLock()
	defer fake.panicMutex.RUnlock()
	fake.fatalMutex.RLock()
	defer fake.fatalMutex.RUnlock()
	fake.sessionMutex.RLock()
	defer fake.sessionMutex.RUnlock()
	fake.sessionNameMutex.RLock()
	defer fake.sessionNameMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeLogger) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ logger.Logger = new(FakeLogger)
