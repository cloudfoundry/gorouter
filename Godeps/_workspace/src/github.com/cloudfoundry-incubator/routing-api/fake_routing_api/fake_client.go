// This file was generated by counterfeiter
package fake_routing_api

import (
	"sync"

	"github.com/cloudfoundry-incubator/routing-api"
	"github.com/cloudfoundry-incubator/routing-api/models"
)

type FakeClient struct {
	SetTokenStub        func(string)
	setTokenMutex       sync.RWMutex
	setTokenArgsForCall []struct {
		arg1 string
	}
	UpsertRoutesStub        func([]models.Route) error
	upsertRoutesMutex       sync.RWMutex
	upsertRoutesArgsForCall []struct {
		arg1 []models.Route
	}
	upsertRoutesReturns struct {
		result1 error
	}
	RoutesStub        func() ([]models.Route, error)
	routesMutex       sync.RWMutex
	routesArgsForCall []struct{}
	routesReturns     struct {
		result1 []models.Route
		result2 error
	}
	DeleteRoutesStub        func([]models.Route) error
	deleteRoutesMutex       sync.RWMutex
	deleteRoutesArgsForCall []struct {
		arg1 []models.Route
	}
	deleteRoutesReturns struct {
		result1 error
	}
	RouterGroupsStub        func() ([]models.RouterGroup, error)
	routerGroupsMutex       sync.RWMutex
	routerGroupsArgsForCall []struct{}
	routerGroupsReturns     struct {
		result1 []models.RouterGroup
		result2 error
	}
	UpsertTcpRouteMappingsStub        func([]models.TcpRouteMapping) error
	upsertTcpRouteMappingsMutex       sync.RWMutex
	upsertTcpRouteMappingsArgsForCall []struct {
		arg1 []models.TcpRouteMapping
	}
	upsertTcpRouteMappingsReturns struct {
		result1 error
	}
	DeleteTcpRouteMappingsStub        func([]models.TcpRouteMapping) error
	deleteTcpRouteMappingsMutex       sync.RWMutex
	deleteTcpRouteMappingsArgsForCall []struct {
		arg1 []models.TcpRouteMapping
	}
	deleteTcpRouteMappingsReturns struct {
		result1 error
	}
	TcpRouteMappingsStub        func() ([]models.TcpRouteMapping, error)
	tcpRouteMappingsMutex       sync.RWMutex
	tcpRouteMappingsArgsForCall []struct{}
	tcpRouteMappingsReturns     struct {
		result1 []models.TcpRouteMapping
		result2 error
	}
	SubscribeToEventsStub        func() (routing_api.EventSource, error)
	subscribeToEventsMutex       sync.RWMutex
	subscribeToEventsArgsForCall []struct{}
	subscribeToEventsReturns     struct {
		result1 routing_api.EventSource
		result2 error
	}
	SubscribeToEventsWithMaxRetriesStub        func(retries uint16) (routing_api.EventSource, error)
	subscribeToEventsWithMaxRetriesMutex       sync.RWMutex
	subscribeToEventsWithMaxRetriesArgsForCall []struct {
		retries uint16
	}
	subscribeToEventsWithMaxRetriesReturns struct {
		result1 routing_api.EventSource
		result2 error
	}
	SubscribeToTcpEventsStub        func() (routing_api.TcpEventSource, error)
	subscribeToTcpEventsMutex       sync.RWMutex
	subscribeToTcpEventsArgsForCall []struct{}
	subscribeToTcpEventsReturns     struct {
		result1 routing_api.TcpEventSource
		result2 error
	}
	SubscribeToTcpEventsWithMaxRetriesStub        func(retries uint16) (routing_api.TcpEventSource, error)
	subscribeToTcpEventsWithMaxRetriesMutex       sync.RWMutex
	subscribeToTcpEventsWithMaxRetriesArgsForCall []struct {
		retries uint16
	}
	subscribeToTcpEventsWithMaxRetriesReturns struct {
		result1 routing_api.TcpEventSource
		result2 error
	}
}

func (fake *FakeClient) SetToken(arg1 string) {
	fake.setTokenMutex.Lock()
	fake.setTokenArgsForCall = append(fake.setTokenArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.setTokenMutex.Unlock()
	if fake.SetTokenStub != nil {
		fake.SetTokenStub(arg1)
	}
}

func (fake *FakeClient) SetTokenCallCount() int {
	fake.setTokenMutex.RLock()
	defer fake.setTokenMutex.RUnlock()
	return len(fake.setTokenArgsForCall)
}

func (fake *FakeClient) SetTokenArgsForCall(i int) string {
	fake.setTokenMutex.RLock()
	defer fake.setTokenMutex.RUnlock()
	return fake.setTokenArgsForCall[i].arg1
}

func (fake *FakeClient) UpsertRoutes(arg1 []models.Route) error {
	fake.upsertRoutesMutex.Lock()
	fake.upsertRoutesArgsForCall = append(fake.upsertRoutesArgsForCall, struct {
		arg1 []models.Route
	}{arg1})
	fake.upsertRoutesMutex.Unlock()
	if fake.UpsertRoutesStub != nil {
		return fake.UpsertRoutesStub(arg1)
	} else {
		return fake.upsertRoutesReturns.result1
	}
}

func (fake *FakeClient) UpsertRoutesCallCount() int {
	fake.upsertRoutesMutex.RLock()
	defer fake.upsertRoutesMutex.RUnlock()
	return len(fake.upsertRoutesArgsForCall)
}

func (fake *FakeClient) UpsertRoutesArgsForCall(i int) []models.Route {
	fake.upsertRoutesMutex.RLock()
	defer fake.upsertRoutesMutex.RUnlock()
	return fake.upsertRoutesArgsForCall[i].arg1
}

func (fake *FakeClient) UpsertRoutesReturns(result1 error) {
	fake.UpsertRoutesStub = nil
	fake.upsertRoutesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Routes() ([]models.Route, error) {
	fake.routesMutex.Lock()
	fake.routesArgsForCall = append(fake.routesArgsForCall, struct{}{})
	fake.routesMutex.Unlock()
	if fake.RoutesStub != nil {
		return fake.RoutesStub()
	} else {
		return fake.routesReturns.result1, fake.routesReturns.result2
	}
}

func (fake *FakeClient) RoutesCallCount() int {
	fake.routesMutex.RLock()
	defer fake.routesMutex.RUnlock()
	return len(fake.routesArgsForCall)
}

func (fake *FakeClient) RoutesReturns(result1 []models.Route, result2 error) {
	fake.RoutesStub = nil
	fake.routesReturns = struct {
		result1 []models.Route
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteRoutes(arg1 []models.Route) error {
	fake.deleteRoutesMutex.Lock()
	fake.deleteRoutesArgsForCall = append(fake.deleteRoutesArgsForCall, struct {
		arg1 []models.Route
	}{arg1})
	fake.deleteRoutesMutex.Unlock()
	if fake.DeleteRoutesStub != nil {
		return fake.DeleteRoutesStub(arg1)
	} else {
		return fake.deleteRoutesReturns.result1
	}
}

func (fake *FakeClient) DeleteRoutesCallCount() int {
	fake.deleteRoutesMutex.RLock()
	defer fake.deleteRoutesMutex.RUnlock()
	return len(fake.deleteRoutesArgsForCall)
}

func (fake *FakeClient) DeleteRoutesArgsForCall(i int) []models.Route {
	fake.deleteRoutesMutex.RLock()
	defer fake.deleteRoutesMutex.RUnlock()
	return fake.deleteRoutesArgsForCall[i].arg1
}

func (fake *FakeClient) DeleteRoutesReturns(result1 error) {
	fake.DeleteRoutesStub = nil
	fake.deleteRoutesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RouterGroups() ([]models.RouterGroup, error) {
	fake.routerGroupsMutex.Lock()
	fake.routerGroupsArgsForCall = append(fake.routerGroupsArgsForCall, struct{}{})
	fake.routerGroupsMutex.Unlock()
	if fake.RouterGroupsStub != nil {
		return fake.RouterGroupsStub()
	} else {
		return fake.routerGroupsReturns.result1, fake.routerGroupsReturns.result2
	}
}

func (fake *FakeClient) RouterGroupsCallCount() int {
	fake.routerGroupsMutex.RLock()
	defer fake.routerGroupsMutex.RUnlock()
	return len(fake.routerGroupsArgsForCall)
}

func (fake *FakeClient) RouterGroupsReturns(result1 []models.RouterGroup, result2 error) {
	fake.RouterGroupsStub = nil
	fake.routerGroupsReturns = struct {
		result1 []models.RouterGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpsertTcpRouteMappings(arg1 []models.TcpRouteMapping) error {
	fake.upsertTcpRouteMappingsMutex.Lock()
	fake.upsertTcpRouteMappingsArgsForCall = append(fake.upsertTcpRouteMappingsArgsForCall, struct {
		arg1 []models.TcpRouteMapping
	}{arg1})
	fake.upsertTcpRouteMappingsMutex.Unlock()
	if fake.UpsertTcpRouteMappingsStub != nil {
		return fake.UpsertTcpRouteMappingsStub(arg1)
	} else {
		return fake.upsertTcpRouteMappingsReturns.result1
	}
}

func (fake *FakeClient) UpsertTcpRouteMappingsCallCount() int {
	fake.upsertTcpRouteMappingsMutex.RLock()
	defer fake.upsertTcpRouteMappingsMutex.RUnlock()
	return len(fake.upsertTcpRouteMappingsArgsForCall)
}

func (fake *FakeClient) UpsertTcpRouteMappingsArgsForCall(i int) []models.TcpRouteMapping {
	fake.upsertTcpRouteMappingsMutex.RLock()
	defer fake.upsertTcpRouteMappingsMutex.RUnlock()
	return fake.upsertTcpRouteMappingsArgsForCall[i].arg1
}

func (fake *FakeClient) UpsertTcpRouteMappingsReturns(result1 error) {
	fake.UpsertTcpRouteMappingsStub = nil
	fake.upsertTcpRouteMappingsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteTcpRouteMappings(arg1 []models.TcpRouteMapping) error {
	fake.deleteTcpRouteMappingsMutex.Lock()
	fake.deleteTcpRouteMappingsArgsForCall = append(fake.deleteTcpRouteMappingsArgsForCall, struct {
		arg1 []models.TcpRouteMapping
	}{arg1})
	fake.deleteTcpRouteMappingsMutex.Unlock()
	if fake.DeleteTcpRouteMappingsStub != nil {
		return fake.DeleteTcpRouteMappingsStub(arg1)
	} else {
		return fake.deleteTcpRouteMappingsReturns.result1
	}
}

func (fake *FakeClient) DeleteTcpRouteMappingsCallCount() int {
	fake.deleteTcpRouteMappingsMutex.RLock()
	defer fake.deleteTcpRouteMappingsMutex.RUnlock()
	return len(fake.deleteTcpRouteMappingsArgsForCall)
}

func (fake *FakeClient) DeleteTcpRouteMappingsArgsForCall(i int) []models.TcpRouteMapping {
	fake.deleteTcpRouteMappingsMutex.RLock()
	defer fake.deleteTcpRouteMappingsMutex.RUnlock()
	return fake.deleteTcpRouteMappingsArgsForCall[i].arg1
}

func (fake *FakeClient) DeleteTcpRouteMappingsReturns(result1 error) {
	fake.DeleteTcpRouteMappingsStub = nil
	fake.deleteTcpRouteMappingsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) TcpRouteMappings() ([]models.TcpRouteMapping, error) {
	fake.tcpRouteMappingsMutex.Lock()
	fake.tcpRouteMappingsArgsForCall = append(fake.tcpRouteMappingsArgsForCall, struct{}{})
	fake.tcpRouteMappingsMutex.Unlock()
	if fake.TcpRouteMappingsStub != nil {
		return fake.TcpRouteMappingsStub()
	} else {
		return fake.tcpRouteMappingsReturns.result1, fake.tcpRouteMappingsReturns.result2
	}
}

func (fake *FakeClient) TcpRouteMappingsCallCount() int {
	fake.tcpRouteMappingsMutex.RLock()
	defer fake.tcpRouteMappingsMutex.RUnlock()
	return len(fake.tcpRouteMappingsArgsForCall)
}

func (fake *FakeClient) TcpRouteMappingsReturns(result1 []models.TcpRouteMapping, result2 error) {
	fake.TcpRouteMappingsStub = nil
	fake.tcpRouteMappingsReturns = struct {
		result1 []models.TcpRouteMapping
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToEvents() (routing_api.EventSource, error) {
	fake.subscribeToEventsMutex.Lock()
	fake.subscribeToEventsArgsForCall = append(fake.subscribeToEventsArgsForCall, struct{}{})
	fake.subscribeToEventsMutex.Unlock()
	if fake.SubscribeToEventsStub != nil {
		return fake.SubscribeToEventsStub()
	} else {
		return fake.subscribeToEventsReturns.result1, fake.subscribeToEventsReturns.result2
	}
}

func (fake *FakeClient) SubscribeToEventsCallCount() int {
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	return len(fake.subscribeToEventsArgsForCall)
}

func (fake *FakeClient) SubscribeToEventsReturns(result1 routing_api.EventSource, result2 error) {
	fake.SubscribeToEventsStub = nil
	fake.subscribeToEventsReturns = struct {
		result1 routing_api.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToEventsWithMaxRetries(retries uint16) (routing_api.EventSource, error) {
	fake.subscribeToEventsWithMaxRetriesMutex.Lock()
	fake.subscribeToEventsWithMaxRetriesArgsForCall = append(fake.subscribeToEventsWithMaxRetriesArgsForCall, struct {
		retries uint16
	}{retries})
	fake.subscribeToEventsWithMaxRetriesMutex.Unlock()
	if fake.SubscribeToEventsWithMaxRetriesStub != nil {
		return fake.SubscribeToEventsWithMaxRetriesStub(retries)
	} else {
		return fake.subscribeToEventsWithMaxRetriesReturns.result1, fake.subscribeToEventsWithMaxRetriesReturns.result2
	}
}

func (fake *FakeClient) SubscribeToEventsWithMaxRetriesCallCount() int {
	fake.subscribeToEventsWithMaxRetriesMutex.RLock()
	defer fake.subscribeToEventsWithMaxRetriesMutex.RUnlock()
	return len(fake.subscribeToEventsWithMaxRetriesArgsForCall)
}

func (fake *FakeClient) SubscribeToEventsWithMaxRetriesArgsForCall(i int) uint16 {
	fake.subscribeToEventsWithMaxRetriesMutex.RLock()
	defer fake.subscribeToEventsWithMaxRetriesMutex.RUnlock()
	return fake.subscribeToEventsWithMaxRetriesArgsForCall[i].retries
}

func (fake *FakeClient) SubscribeToEventsWithMaxRetriesReturns(result1 routing_api.EventSource, result2 error) {
	fake.SubscribeToEventsWithMaxRetriesStub = nil
	fake.subscribeToEventsWithMaxRetriesReturns = struct {
		result1 routing_api.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToTcpEvents() (routing_api.TcpEventSource, error) {
	fake.subscribeToTcpEventsMutex.Lock()
	fake.subscribeToTcpEventsArgsForCall = append(fake.subscribeToTcpEventsArgsForCall, struct{}{})
	fake.subscribeToTcpEventsMutex.Unlock()
	if fake.SubscribeToTcpEventsStub != nil {
		return fake.SubscribeToTcpEventsStub()
	} else {
		return fake.subscribeToTcpEventsReturns.result1, fake.subscribeToTcpEventsReturns.result2
	}
}

func (fake *FakeClient) SubscribeToTcpEventsCallCount() int {
	fake.subscribeToTcpEventsMutex.RLock()
	defer fake.subscribeToTcpEventsMutex.RUnlock()
	return len(fake.subscribeToTcpEventsArgsForCall)
}

func (fake *FakeClient) SubscribeToTcpEventsReturns(result1 routing_api.TcpEventSource, result2 error) {
	fake.SubscribeToTcpEventsStub = nil
	fake.subscribeToTcpEventsReturns = struct {
		result1 routing_api.TcpEventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToTcpEventsWithMaxRetries(retries uint16) (routing_api.TcpEventSource, error) {
	fake.subscribeToTcpEventsWithMaxRetriesMutex.Lock()
	fake.subscribeToTcpEventsWithMaxRetriesArgsForCall = append(fake.subscribeToTcpEventsWithMaxRetriesArgsForCall, struct {
		retries uint16
	}{retries})
	fake.subscribeToTcpEventsWithMaxRetriesMutex.Unlock()
	if fake.SubscribeToTcpEventsWithMaxRetriesStub != nil {
		return fake.SubscribeToTcpEventsWithMaxRetriesStub(retries)
	} else {
		return fake.subscribeToTcpEventsWithMaxRetriesReturns.result1, fake.subscribeToTcpEventsWithMaxRetriesReturns.result2
	}
}

func (fake *FakeClient) SubscribeToTcpEventsWithMaxRetriesCallCount() int {
	fake.subscribeToTcpEventsWithMaxRetriesMutex.RLock()
	defer fake.subscribeToTcpEventsWithMaxRetriesMutex.RUnlock()
	return len(fake.subscribeToTcpEventsWithMaxRetriesArgsForCall)
}

func (fake *FakeClient) SubscribeToTcpEventsWithMaxRetriesArgsForCall(i int) uint16 {
	fake.subscribeToTcpEventsWithMaxRetriesMutex.RLock()
	defer fake.subscribeToTcpEventsWithMaxRetriesMutex.RUnlock()
	return fake.subscribeToTcpEventsWithMaxRetriesArgsForCall[i].retries
}

func (fake *FakeClient) SubscribeToTcpEventsWithMaxRetriesReturns(result1 routing_api.TcpEventSource, result2 error) {
	fake.SubscribeToTcpEventsWithMaxRetriesStub = nil
	fake.subscribeToTcpEventsWithMaxRetriesReturns = struct {
		result1 routing_api.TcpEventSource
		result2 error
	}{result1, result2}
}

var _ routing_api.Client = new(FakeClient)
